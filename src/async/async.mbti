package "tonyfettes/uv/async"

import(
  "moonbitlang/core/buffer"
  "moonbitlang/core/builtin"
  "moonbitlang/core/bytes"
  "moonbitlang/core/json"
  "moonbitlang/core/string"
  "tonyfettes/encoding"
  "tonyfettes/uv"
)

// Values
let active_scope : Ref[Scope?]

fn args() -> Array[String]

async fn[T] backtrace(loc~ : SourceLoc = _, async () -> T raise) -> T raise

fn backtrace_to_string() -> String

fn cancel() -> Unit raise

#deprecated
fn cwd() -> Path raise

async fn delay(Int) -> Unit raise

let env : Env

fn launch(async () -> Unit raise) -> Unit raise

fn[ToPath : ToPath] path(ToPath) -> Path

async fn[T] scope(async () -> T raise) -> T raise

async fn[Exec : Executable] spawn(Exec, Array[@string.StringView], cwd? : &ToPath, stdin~ : ProcessInput = .., stdout~ : ProcessOutput = .., stderr~ : ProcessOutput = ..) -> Process raise

fn[T] start(async () -> T raise) -> T raise

let stderr : File

let stdin : File

let stdout : File

fn system() -> String raise

async fn[R] with_temporary_directory(async (Path) -> R raise, loc~ : SourceLoc = _) -> R raise

// Types and methods
type Channel[T]
fn[T] Channel::cancel(Self[T]) -> Unit
fn[T] Channel::new() -> Self[T]
async fn[T] Channel::recv(Self[T]) -> T raise
async fn[T] Channel::send(Self[T], T) -> Unit raise

pub type! Dead

type Env
fn Env::get(Self, String) -> String? raise
fn Env::iter2(Self) -> Iter2[String, String] raise
fn Env::op_get(Self, String) -> String raise
fn Env::op_set(Self, String, String) -> Unit raise

type File
async fn File::close(Self, loc~ : SourceLoc = _) -> Unit raise
impl Readable for File
impl Writable for File

pub suberror FileSystemError {
  AlreadyExists(Path)
  IsDirectory(Path)
  NotDirectory(Path)
  NotEmpty(Path)
  NotFound(Path)
  NotSupported(String)
  Unknown(@uv.Errno)
}

pub enum FileType {
  File
  Directory
  Symlink
  Socket
  Fifo
  BlockDevice
  CharacterDevice
  Unknown
}

type Id
fn Id::new() -> Self
impl Eq for Id
impl Hash for Id
impl Show for Id

type Iter[T]
async fn[T, U] Iter::bind(Self[T], async (T) -> U? raise?) -> Self[U]
async fn Iter::bytes(Self[@bytes.View]) -> Bytes raise
async fn[T] Iter::collect(Self[T]) -> Array[T] raise
async fn Iter::decode(Self[@bytes.View], encoding~ : @encoding.Encoding) -> Self[String]
async fn[T] Iter::each(Self[T], async (T) -> Unit raise) -> Unit raise
async fn[T] Iter::filter(Self[T], async (T) -> Bool raise?) -> Self[T]
async fn Iter::text(Self[@bytes.View], encoding~ : @encoding.Encoding = ..) -> String raise

pub suberror MultiError Array[Error]
impl Show for MultiError

type Path
async fn Path::access(Self, read~ : Bool = .., write~ : Bool = .., execute~ : Bool = .., loc~ : SourceLoc = _) -> Unit raise
fn Path::anchor(Self) -> @string.StringView
async fn[Target : ToPath] Path::copy_to(Self, Target, recursive~ : Bool = .., overwrite~ : Bool = .., loc~ : SourceLoc = _) -> Unit raise
fn Path::cwd() -> Self raise
fn Path::drive(Self) -> @string.StringView
async fn Path::exists(Self, loc~ : SourceLoc = _) -> Bool raise
fn Path::glob(Self, @string.StringView) -> Iter[Self] raise
fn Path::home() -> Self raise
async fn Path::is_dir(Self, loc~ : SourceLoc = _) -> Bool raise
async fn Path::is_file(Self) -> Bool raise
async fn Path::iter(Self) -> Iter[Self] raise
fn[ToPath : ToPath] Path::join(Self, ToPath) -> Self
async fn Path::mkdir(Self, mode~ : Int = .., loc~ : SourceLoc = _) -> Unit raise
async fn[Target : ToPath] Path::move_to(Self, Target, loc~ : SourceLoc = _) -> Unit raise
fn Path::name(Self) -> @string.StringView?
fn[ToPath : ToPath] Path::new(ToPath) -> Self
async fn Path::open(Self, loc~ : SourceLoc = _) -> File raise
fn Path::parent(Self) -> Self?
fn Path::parse(@string.StringView) -> Self
fn Path::parts(Self) -> @builtin.Iter[@string.StringView]
fn Path::read(Self, loc~ : SourceLoc = _) -> Iter[@bytes.View] raise
fn[ToPath : ToPath] Path::relative_to(Self, ToPath) -> Self
async fn Path::remove(Self, recursive~ : Bool = .., loc~ : SourceLoc = _) -> Unit raise
async fn Path::resolve(Self, loc~ : SourceLoc = _) -> Self raise
async fn Path::rmdir(Self, loc~ : SourceLoc = _) -> Unit raise
fn Path::root(Self) -> @string.StringView
async fn Path::stat(Self, loc~ : SourceLoc = _) -> Stat raise
fn Path::suffix(Self) -> @string.StringView?
fn Path::to_posix_path(Self) -> Self
fn Path::to_windows_path(Self) -> Self
async fn Path::unlink(Self, loc~ : SourceLoc = _) -> Unit raise
async fn Path::walk(Self, loc~ : SourceLoc = _) -> Iter[Self] raise
async fn Path::write(Self, Iter[@bytes.View], loc~ : SourceLoc = _) -> Unit raise
impl Compare for Path
impl Eq for Path
impl Hash for Path
impl Show for Path
impl ToJson for Path
impl @json.FromJson for Path
impl Executable for Path
impl Readable for Path
impl ToPath for Path
impl Writable for Path

type Pipe
async fn Pipe::close(Self) -> Unit
fn Pipe::new(ipc~ : Bool = ..) -> Self raise
impl Readable for Pipe
impl Writable for Pipe

type Process
fn Process::kill(Self, Signum) -> Unit raise
fn Process::setup_stderr(Self, ProcessOutput, Array[@uv.StdioContainer]) -> Unit
async fn Process::signal(Self) -> Int
async fn Process::status(Self) -> Int
fn Process::stderr(Self) -> Pipe raise
fn Process::stdin(Self) -> Pipe raise
fn Process::stdout(Self) -> Pipe raise
async fn Process::wait(Self) -> Unit

pub(all) enum ProcessInput {
  Ignore
  Stdin
  Pipe(Pipe)
  Inherit(File)
}

pub(all) enum ProcessOutput {
  Ignore
  Stdout
  Stderr
  Pipe(Pipe)
  Inherit(File)
}

pub struct Scope {
  id : Id
  parent : Scope?
  scopes : Map[Id, () -> Unit]
  mut launched : Int
  mut canceled : Bool
  mut accept : (Unit) -> Unit
  mut reject : (Error) -> Unit
  errors : Array[Error]
}

pub(all) enum Signum {
  SIGHUP
  SIGINT
  SIGQUIT
  SIGABRT
  SIGTERM
  SIGWINCH
  SIGPIPE
}

type Stat
fn Stat::is_dir(Self) -> Bool
fn Stat::is_directory(Self) -> Bool
fn Stat::is_file(Self) -> Bool
fn Stat::is_regular(Self) -> Bool
fn Stat::last_accessed(Self) -> Int64
fn Stat::last_changed(Self) -> Int64
fn Stat::last_modified(Self) -> Int64
fn Stat::type_(Self) -> FileType

// Type aliases

// Traits
trait Executable
impl Executable for String

pub trait Readable {
  async read(Self) -> Iter[@bytes.View] raise
  async read_text(Self, encoding~ : @encoding.Encoding) -> String raise
  async read_bytes(Self) -> Bytes raise
}
impl Readable for Bytes
impl Readable for @bytes.View

pub trait ToPath {
  to_path(Self) -> Path
}
impl ToPath for String
impl[T : ToPath] ToPath for Array[T]
impl[T : ToPath] ToPath for ArrayView[T]
impl ToPath for @string.StringView

pub trait Writable {
  async write(Self, Iter[@bytes.View]) -> Unit raise
  async write_text(Self, @string.StringView, encoding~ : @encoding.Encoding) -> Unit raise
  async write_bytes(Self, @bytes.View) -> Unit raise
}
impl Writable for @buffer.T

